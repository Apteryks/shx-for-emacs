#+TITLE: shx for Emacs
#+OPTIONS: toc:3 author:t creator:nil num:nil
#+AUTHOR: Chris Rayner
#+EMAIL: dchrisrayner@gmail.com

[[https://melpa.org/#/shx][http://melpa.org/packages/shx-badge.svg]] [[https://stable.melpa.org/#/shx][https://stable.melpa.org/packages/shx-badge.svg]]

[[file:img/screenshot.png]]

* Table of Contents :TOC_3_gh:noexport:
- [[#description][Description]]
- [[#related][Related]]
- [[#install][Install]]
    - [[#from-melpa][From MELPA]]
    - [[#manually][Manually]]
- [[#run][Run]]
- [[#key-bindings][Key bindings]]
- [[#markup-in-the-shell][Markup in the shell]]
- [[#extra-shell-commands][Extra shell commands]]
    - [[#general-commands][General commands]]
    - [[#graphical-commands][Graphical commands]]
    - [[#asynchronous-commands][Asynchronous commands]]
    - [[#adding-new-commands][Adding new commands]]

* Description
  /shx/ or "shell-extras" extends comint-mode in Emacs (e.g., the ~shell~).

  Parse the output stream in a few useful ways:
  - *Display graphics and plots* in the shell with a simple markup
    language (e.g., ~<view image.png>~)
  - *Add event-driven and timed behaviors* to any shell session
  - *Open any filename or URL* by arrowing up to it and pressing ~<enter>~
  - *Yank any line to the prompt* by arrowing up to it and pressing ~C-<enter>~
  - *Check the time a command was run* by mousing over its prompt

  Write new shell commands in elisp -- and lots already exist:
  - ~:e filename.txt~ opens a file in a new buffer for editing
  - ~:ssh user@host:port~ ssh's to the supplied host using tramp
  - ~:view image_file.png~ displays an image in the shell
  - ~:plotline data_file.txt~ renders a line plot of a data file

  Use ~M-x customize-group RET shx RET~ to see shx's customization options.

  /This version is tested with Emacs 25.2.1/  Check out the [[https://github.com/riscy/shx-for-emacs/releases][release log]].
* Related
  If you're here, these might be interesting:
  - [[https://www.masteringemacs.org/article/shell-comint-secrets-history-commands][Shell & Comint Secrets: History commands]]
  - [[https://www.booleanworld.com/customizing-coloring-bash-prompt/][Creating dynamic bash prompts]]
  - [[https://github.com/Orkohunter/keep][The Keep Utility]] inspired the ~kept~ and ~keep~ commands

  And if running a ~dumb~ terminal in Emacs isn't for you, here are some
  alternatives:
  - [[https://leanpub.com/the-tao-of-tmux/read][The Tao of tmux]], re: working in the terminal with tmux
  - [[http://ohmyz.sh/][oh my zsh]], a community-driven zsh shell configuration
  - [[https://github.com/zsh-users/zsh-syntax-highlighting][zsh-syntax-highlighting]]
  - [[https://hackernoon.com/macbook-my-command-line-utilities-f8a121c3b019#.clz934ly3][Shell configuration tips]] from Vitaly Belman
  - [[https://www.iterm2.com/documentation-shell-integration.html][Shell integration]] for iTerm2 on macOS
  - [[https://getbitbar.com/][BitBar]] for macOS
* Install
*** From MELPA
    ~M-x package-install RET shx RET~ to install shx from [[https://melpa.org/][MELPA]].
*** Manually
    Add the following to your ~.emacs~:
    #+begin_src elisp
    (add-to-list 'load-path "~/path/to/shx/") ; add shx.el's directory to the load-path
    (require 'shx)                            ; load shell-extras
    #+end_src
* Run
  Typing ~M-x shx <return>~ begins a new ~shell~ session with shx enabled.  The
  following commands will get you started:
  1. Type ~:man ls~ and the man page for ~ls~ will be brought up within Emacs.
  2. Type ~:help~ and you'll enter a completing read for shx commands that you
     can run besides ~:man~ and ~:help~.

  If you like shx-mode, you can enable it everywhere:

  #+begin_src elisp
  (shx-global-mode 1)                       ; toggle shx-mode on globally
  #+end_src

  Now shx will run automatically in any ~comint-mode~ buffer.  If you don't want
  shx to run in every comint-mode buffer, you can use ~M-x shx-mode~ on a
  case-by-case basis, or just add hooks to the mode in question, for example:

  #+begin_src elisp
  (add-hook 'inferior-python-mode-hook #'shx-mode)
  #+end_src
* Key bindings
  | Key binding | Description                                                              |
  |-------------+--------------------------------------------------------------------------|
  | ~C-RET~     | If the cursor is not on the prompt, paste the current line to the input  |
  | ~RET~       | If the cursor is on a filename or a URL, try to open it                  |
  | ~SPC~       | If the prompt is ~:~, send ~SPC~ straight through to the process         |
  | ~q~         | If the prompt is ~:~, send ~q~ straight through to the process           |

  Note the prompt will be ~:~ when reading through the output of ~less~ or a ~man~ page
  if you run the following:
  #+begin_src elisp
  (setenv "LESS" "--dumb --prompt=s")
  #+end_src
* Markup in the shell
  shx's markup can enhance basic command-line applications and drive other
  events.

  If the output ever contains ~<view mountains.png>~ on a line by itself, then a
  scaled rendering of ~mountains.png~ will be inlined within the text in the
  shell.  This works because ~view~ is a shx command.  shx will execute any
  (safe) shx command that appears with the following syntax:
  #+begin_src xml
  <command arg1 arg2 ...>
  #+end_src
  where ~command~ is a shx command and ~arg1 ... argn~ are a space-separated
  list of arguments.  Arguments don't need to be surrounded by quotes -- the
  command will figure out how to parse them.

  You can use this markup to create a barplot (~:plotbar~) after collecting some
  stats, or generate an ~:alert~ when a task is finished, and so forth.
* Extra shell commands
  shx's 'extra' commands are invoked by typing a ~:~ followed by the command's
  name.  These are written in elisp and so can access all of Emacs' facilities.
  Type ~:help~ to see a complete listing of shx commands.

  The command I use most frequently is the ~:edit~ (shorthand ~:e~) command:
  #+begin_src bash
  # edit the .emacs file:
  :edit ~/.emacs

  # use tramp to edit the .emacs file on a remote host:
  :e remote-host.com:~/.emacs
  #+end_src

  Because these commands are written in elisp, shx gives the ~shell~ a lot of
  the same advantages as ~eshell~.  You can even evaluate elisp code directly in
  the buffer (see ~:help eval~).

  Change the ~:~ prefix by customizing the ~shx-leader~ variable.
*** General commands
    | Command              | Description                                           |
    |----------------------+-------------------------------------------------------|
    | ~:clear~             | Clear the buffer                                      |
    | ~:diff file1 file2~  | Launch an Emacs diff between two files                |
    | ~:edit file~         | Edit a file.  Shortcut: ~:e <file>~                   |
    | ~:eval (elisp-sexp)~ | Evaluate some elisp code.  Example: ~eval (pwd)~      |
    | ~:man topic~         | Invoke the Emacs man page browser on a topic          |
    | ~:header New header~ | Change the current ~header-line-format~               |
    | ~:ssh host~          | Open another shell on the specified host              |
    | ~:kept regexp~       | Show a list of your 'kept' commands matching regexp   |
    | ~:keep~              | Add the previous command to the list of kept commands |

    There are many more than this -- type ~:help~ for a listing of all user commands.
*** Graphical commands
    | Command                      | Description            |
    |------------------------------+------------------------|
    | ~:view image_file.jpg~       | Display an image       |
    | ~:plotbar data_file.txt~     | Display a bar plot     |
    | ~:plotmatrix data_file.txt~  | Display a heatmap      |
    | ~:plotline data_file.txt~    | Display a line plot    |
    | ~:plot3d data_file.txt~      | Display a 3D plot      |
    | ~:plotscatter data_file.txt~ | Display a scatter plot |

    These are for displaying inline graphics and plots in the shell buffer.  You
    can control how much vertical space an inline image occupies by customizing
    the ~shx-imgsize~ variable.  Note ~convert~ (i.e., ImageMagick) and
    ~gnuplot~ need to be installed.  If the binaries are installed but these
    commands aren't working, customize the ~shx-path-to-convert~ and
    ~shx-path-to-gnuplot~ variables to point to the binaries.
*** Asynchronous commands
    | Command                           | Description                                       |
    |-----------------------------------+---------------------------------------------------|
    | ~:delay <sec> <command>~          | Run a shell command after a specific delay        |
    | ~:pulse <sec> <command>~          | Repeat a shell command forever with a given delay |
    | ~:repeat <count> <sec> <command>~ | Repeat a shell command ~<count>~ times            |
    | ~:stop <num>~                     | Cancel a repeating or delayed command             |

    Use these to delay, pulse, or repeat a command a specific number of times.
    Unfortunately these only support your typical shell commands, and not shx's
    extra (colon-prefixed) commands.  So this possible:
    #+begin_src bash
    # Run the 'pwd' command 10 seconds from now:
    :delay 10 pwd
    #+end_src
    But this is not possible:
    #+begin_src bash
    # Run the 'pwd' shx command 10 seconds from now (DOES NOT WORK)
    :delay 10 :pwd
    #+end_src
*** Adding new commands
    New commands are written by defining single-argument elisp functions named
    ~shx-cmd-COMMAND-NAME~, where ~COMMAND-NAME~ is what the user would type to
    invoke it.
***** Example: a command to rename the buffer
    If you execute the following (or add it to your ~.emacs~),
    #+begin_src elisp
    (defun shx-cmd-name (name)
      "(SAFE) Rename the current buffer to NAME."
      (if (ignore-errors (rename-buffer (concat "*" name "*")))
          (shx-insert "Renaming buffer to *" name "*\n")
        (shx-insert 'error "Can't rename buffer to *" name "* (is this name taken?)\n")))
    #+end_src
    then each shx buffer will immediately have access to the ~:name~ command.

    Note the importance of defining a comment string.  This documents the
    command so that typing ~:help name~ will give the user information on what
    the command does.  Further, if the comment string begins with ~(SAFE)~ then
    it becomes part of shx's markup language.  So in this case if:
    #+begin_src xml
    <name A new name for the buffer>
    #+end_src
    appears on a line by itself in the output, the buffer will try to
    automatically rename itself.

***** Example: a command to browse URLs
      If you execute the following,
      #+begin_src elisp
      (defun shx-cmd-browse (url)
        "Browse the supplied URL."
        (shx-insert "Browsing " 'font-lock-keyword-face url)
        (browse-url url))
      #+end_src
      then each shx buffer will have access to the ~:browse~ command.

      Note the comment string does not specify that this command is ~SAFE~.
      This means ~<browse url>~ will not become part of shx's markup.  That
      makes sense in this case, since you wouldn't want to give a process the
      power to open arbitrary URLs without prompting.
